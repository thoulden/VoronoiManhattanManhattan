<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Manhattan Voronoi (L1 / L2)</title>
<style>
  :root {
    --bg: #f8f7f2;
    --fg: #111;
    --accent: #0b6;
  }

  body {
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    background: var(--bg);
    color: var(--fg);
  }

  header {
    padding: 60px 40px;
    display: flex;
    flex-direction: column;
    gap: 0;
    background: transparent; /* ✅ no white box */
  }

  header strong {
    font-size: 140px; /* ✅ much larger text */
    font-weight: 800;
    line-height: 1;
    background: none; /* ✅ ensure no background */
  }

  #container {
    position: relative;
  }

  canvas {
    display: block;
    width: min(100vw, 1100px);
    height: auto;
    margin: 0 auto 16px auto;
    background: var(--bg);
  }

  #status {
    text-align: center;
    padding: 6px 0 12px;
    font-size: 13px;
    color: #666;
  }
</style>
</head>
<body>
  <header>
    <strong>Manhattan Voronoi</strong>
    <label>Metric:
      <select id="metric">
        <option value="l1" selected>Manhattan (L1)</option>
        <option value="l2">Euclidean (L2)</option>
      </select>
    </label>
    <label id="angleWrap">L1 angle:
      <input id="angle" type="range" min="-45" max="45" step="1" value="29" />
      <span id="angleVal">29°</span>
    </label>
    <label>Resolution (px):
      <select id="res">
        <!-- This controls how densely we sample pixels when coloring (1 = every pixel, 2 = every 2nd pixel, etc.) -->
        <option value="2" selected>Fast (2)</option>
        <option value="1">Fine (1)</option>
        <option value="3">Faster (3)</option>
        <option value="4">Fastest (4)</option>
      </select>
    </label>
    <button id="redraw">Redraw</button>
  </header>

  <div id="container">
    <canvas id="c" width="1100" height="2200"></canvas>
  </div>
  <div id="status">Loading…</div>

<script type="module">
async function main() {
  const status = document.getElementById('status');
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { willReadFrequently: false });

  // UI
  const metricEl = document.getElementById('metric');
  const angleWrap = document.getElementById('angleWrap');
  const angleEl = document.getElementById('angle');
  const angleVal = document.getElementById('angleVal');
  const resEl = document.getElementById('res');
  const redrawBtn = document.getElementById('redraw');

  // Load data (relative paths)
  const [boundary, stations] = await Promise.all([
    fetch('https://raw.githubusercontent.com/thoulden/VoronoiManhattanManhattan/main/site/data/manhattan_boundary.geojson'),
    fetch('https://raw.githubusercontent.com/thoulden/VoronoiManhattanManhattan/main/site/data/manhattan_stations.geojson')
  ]);

  // Basic helpers
  const fcToPolysLonLat = (fc) => {
    // expects a single Polygon or MultiPolygon
    const polys = [];
    for (const feat of fc.features) {
      const g = feat.geometry;
      if (g.type === 'Polygon') polys.push(g.coordinates[0]); // outer ring only
      if (g.type === 'MultiPolygon') for (const poly of g.coordinates) polys.push(poly[0]);
    }
    return polys; // array of rings: [[ [lon,lat], ... ], ...]
  };

  const fcToPointsLonLat = (fc) => {
    const pts = [];
    for (const feat of fc.features) {
      if (feat.geometry?.type === 'Point') {
        const [lon,lat] = feat.geometry.coordinates;
        pts.push([lon,lat]);
      }
    }
    return pts;
  };

  // Minimal mercator projection that we fit to canvas
  function mercatorProject(lon, lat) {
    const λ = lon * Math.PI/180;
    const φ = Math.max(Math.min(lat* Math.PI/180, Math.PI/2 - 1e-6), -Math.PI/2 + 1e-6);
    const x = λ;
    const y = Math.log(Math.tan(Math.PI/4 + φ/2));
    return [x, y];
  }

  // Fit projection to boundary
  const rings = fcToPolysLonLat(boundary);
  const projected = rings.map(r => r.map(([lon,lat]) => mercatorProject(lon,lat)));

  // Compute bounds in projected space
  let minX=+Infinity, minY=+Infinity, maxX=-Infinity, maxY=-Infinity;
  for (const ring of projected) {
    for (const [x,y] of ring) {
      if (x<minX) minX=x; if (x>maxX) maxX=x;
      if (y<minY) minY=y; if (y>maxY) maxY=y;
    }
  }
  const pad = 0.04; // add a bit of margin
  minX -= pad; maxX += pad; minY -= pad; maxY += pad;

  // Build transform: projected -> canvas
  function toCanvas([x,y]) {
    const W = canvas.width, H = canvas.height;
    const sx = W / (maxX - minX);
    const sy = H / (maxY - minY);
    const s = Math.min(sx, sy);     // preserve aspect
    const ox = (W - s*(maxX-minX))/2;
    const oy = (H - s*(maxY-minY))/2;
    const cx = ox + s * (x - minX);
    const cy = oy + s * (maxY - y); // flip Y (mercator y grows upward)
    return [cx, cy];
  }

  // Prepare canvas clip path from boundary (for fast masking)
  function setClip() {
    ctx.save();
    ctx.beginPath();
    for (const ring of projected) {
      const [x0,y0] = toCanvas(ring[0]);
      ctx.moveTo(x0,y0);
      for (let i=1;i<ring.length;i++) {
        const [xi,yi] = toCanvas(ring[i]);
        ctx.lineTo(xi,yi);
      }
      ctx.closePath();
    }
    ctx.clip('nonzero');
  }

  // Project station points to canvas pixels
  const stationLonLat = fcToPointsLonLat(stations);
  const stationXY = stationLonLat.map(([lon,lat]) => toCanvas(mercatorProject(lon,lat)));

  // Simple color palette (repeat)
  const palette = Array.from({length: 20}, (_,i) => `hsl(${(i*360/20)|0} 70% 45%)`);

  // Distance functions (in canvas pixel space)
  const rotate = (x,y,deg) => {
    const t = deg * Math.PI/180;
    const c = Math.cos(t), s = Math.sin(t);
    return [ c*x + s*y, -s*x + c*y ];
  };

  function nearestIndexL1(x,y,deg=0) {
    if (deg !== 0) [x,y] = rotate(x,y,deg);
    let bestIdx = 0, best = Infinity;
    for (let i=0;i<stationXY.length;i++) {
      let [sx,sy] = stationXY[i];
      if (deg !== 0) [sx,sy] = rotate(sx,sy,deg);
      const d = Math.abs(x - sx) + Math.abs(y - sy);
      if (d < best) { best = d; bestIdx = i; }
    }
    return bestIdx;
  }

  function nearestIndexL2(x,y) {
    let bestIdx = 0, best = Infinity;
    for (let i=0;i<stationXY.length;i++) {
      const [sx,sy] = stationXY[i];
      const dx = x - sx, dy = y - sy;
      const d = dx*dx + dy*dy;
      if (d < best) { best = d; bestIdx = i; }
    }
    return bestIdx;
  }

  // Progressive raster paint (column stripes) with clipping for speed
  async function render() {
    const metric = metricEl.value; 
    const res = parseInt(resEl.value, 10); // step size in pixels
    const angle = parseFloat(angleEl.value);
    angleVal.textContent = `${angle|0}°`;
    status.textContent = `Rendering (${metric.toUpperCase()} @ step=${res})…`;

    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Clip to Manhattan outline so we only see inside the island
    setClip();

    const W = canvas.width, H = canvas.height;
    // Paint in vertical bands to keep UI responsive
    let x = 0;
    const band = 8*res; // number of columns per frame
    function step() {
      const xEnd = Math.min(W, x + band);
      for (let xi = x; xi < xEnd; xi += res) {
        for (let yi = 0; yi < H; yi += res) {
          const idx = (metric === 'l1')
            ? nearestIndexL1(xi + 0.5*res, yi + 0.5*res, angle)
            : nearestIndexL2(xi + 0.5*res, yi + 0.5*res);
          ctx.fillStyle = palette[idx % palette.length];
          ctx.fillRect(xi, yi, res, res);
        }
      }
      x = xEnd;
      if (x < W) {
        requestAnimationFrame(step);
      } else {
        // draw stations and outline on top
        ctx.restore(); // remove clip to stroke outline cleanly
        drawOutline();
        drawStations();
        status.textContent = `Done. ${stationXY.length} stations.`;
      }
    }
    requestAnimationFrame(step);
  }

  function drawOutline() {
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#111';
    ctx.beginPath();
    for (const ring of projected) {
      const [x0,y0] = toCanvas(ring[0]);
      ctx.moveTo(x0,y0);
      for (let i=1;i<ring.length;i++) {
        const [xi,yi] = toCanvas(ring[i]);
        ctx.lineTo(xi,yi);
      }
      ctx.closePath();
    }
    ctx.stroke();
  }

  function drawStations() {
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#fff';
    ctx.fillStyle = '#111';
    for (const [x,y] of stationXY) {
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
    }
  }

  // UI wiring
  metricEl.addEventListener('change', () => {
    angleWrap.style.display = (metricEl.value === 'l1') ? 'inline-flex' : 'none';
  });
  angleEl.addEventListener('input', () => {
    angleVal.textContent = `${angleEl.value}°`;
  });
  redrawBtn.addEventListener('click', render);

  // Initial render
  metricEl.dispatchEvent(new Event('change'));
  await render();
}

main().catch(err => {
  document.getElementById('status').textContent = 'Error: ' + err;
  console.error(err);
});
</script>
</body>
</html>
