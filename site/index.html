<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Manhattan Voronoi (L1 / L2)</title>
<style>
  :root { --bg:#f8f7f2; --fg:#111; --muted:#777; }
  body { margin:0; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:var(--bg); color:var(--fg); }
  header { padding:14px 16px; display:flex; gap:12px; align-items:center; flex-wrap:wrap; border-bottom:1px solid #ddd; }
  header h1 { font-size:16px; margin:0 12px 0 0; font-weight:600; }
  label { font-size:13px; color:var(--muted); margin-right:6px; }
  select, input[type="range"], button { font:inherit; }
  #wrap { display:flex; justify-content:center; padding:14px; }
  canvas { background:var(--bg); border:1px solid #ccc; border-radius:10px; box-shadow:0 2px 18px rgba(0,0,0,.07); }
  footer { padding:10px 16px; color:var(--muted); font-size:12px; }
</style>
</head>
<body>
<header>
  <h1>Manhattan Voronoi</h1>

  <div>
    <label>Dataset</label>
    <select id="dataset">
      <option value="rail">Railway stations (demo)</option>
    </select>
  </div>

  <div>
    <label>Metric</label>
    <select id="metric">
      <option value="l1" selected>Manhattan (L1)</option>
      <option value="l2">Euclidean (L2)</option>
    </select>
  </div>

  <div>
    <label>Resolution</label>
    <input id="res" type="range" min="2" max="12" step="1" value="6" />
    <span id="resLabel"></span>
  </div>

  <button id="renderBtn">Render</button>
</header>

<div id="wrap">
  <canvas id="c" width="900" height="1400"></canvas>
</div>

<footer>
  Uses boundary clip for the shoreline, and per-pixel nearest site with your chosen metric.
</footer>

<script type="module">
/* -----------------------------------------------------------
   Minimal client-side Voronoi renderer with clipping
   ----------------------------------------------------------- */
import * as d3 from "https://cdn.skypack.dev/d3@7";

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
const W = canvas.width, H = canvas.height;

const metricSel = document.getElementById("metric");
const resInput  = document.getElementById("res");
const resLabel  = document.getElementById("resLabel");
const renderBtn = document.getElementById("renderBtn");

resLabel.textContent = resInput.value + " (higher = faster)";

/** Manhattan and Euclidean metrics in SCREEN space */
const manhattan = (ax, ay, bx, by) => Math.abs(ax-bx) + Math.abs(ay-by);
const euclid2   = (ax, ay, bx, by) => { const dx=ax-bx, dy=ay-by; return dx*dx + dy*dy; };

/** Load boundary + sites (fallbacks included) */
async function loadData() {
  let boundary, sites;
  try {
    boundary = await (await fetch("data/manhattan_boundary.geojson")).json();
  } catch {
    // very coarse fallback rectangle so the demo still runs
    boundary = {
      type:"FeatureCollection",
      features:[{ type:"Feature", geometry:{ type:"Polygon",
        coordinates:[ [[-74.03,40.69],[-73.92,40.69],[-73.92,40.88],[-74.03,40.88],[-74.03,40.69]] ]
      }}]
    };
  }
  try {
    sites = await (await fetch("data/railway_station_points.json")).json();
  } catch {
    // fallback: 80 scattered points in roughly Manhattan bbox
    const rnd = d3.randomUniform.source(Math.random)(0,1);
    const pts = d3.range(80).map(() => ([
      -74.02 + rnd()*0.09, // lon
       40.70 + rnd()*0.17  // lat
    ]));
    sites = pts.map(([lon,lat]) => ({ lon, lat, name:"demo" }));
  }
  return { boundary, sites };
}

/** Build a mercator projection that fits the canvas nicely */
function fitProjection(boundaryGeo) {
  const projection = d3.geoMercator();
  const path = d3.geoPath(projection, ctx);
  projection.fitExtent([[20, 20],[W-20, H-20]], boundaryGeo);
  return { projection, path };
}

/** Create a Path2D clip from boundary (multi-polys ok) */
function boundaryPath2D(boundaryGeo, projection) {
  const p = new Path2D();
  const path2 = d3.geoPath(projection, new class {
    moveTo(x,y){ p.moveTo(x,y); } lineTo(x,y){ p.lineTo(x,y); }
    closePath(){ p.closePath(); } beginPath(){} arc(){} // minimal sink
  });
  path2(boundaryGeo);
  return p;
}

/** Render Voronoi by per-pixel nearest site (block scan), then clip to boundary */
function renderVoronoi({ sitesXY, metric, step, clipPath }) {
  // Draw background
  ctx.save();
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = "#f8f7f2";
  ctx.fillRect(0,0,W,H);

  // Clip to the boundary so shoreline is crisp
  ctx.clip(clipPath);

  // Color palette (repeat)
  const palette = d3.schemeTableau10.concat(d3.schemeSet3, d3.schemePaired);

  // Prepare an ImageData we’ll paint into by blocks
  const img = ctx.getImageData(0,0,W,H);
  const data = img.data;

  const cols = Math.ceil(W / step);
  const rows = Math.ceil(H / step);

  // Process by small tiles to keep UI responsive
  const blockRows = 80;
  let r0 = 0;

  function processChunk() {
    const r1 = Math.min(r0 + blockRows, rows);
    for (let ry = r0; ry < r1; ry++) {
      const yCenter = Math.min(H-1, Math.floor(ry*step + step/2));
      for (let rx = 0; rx < cols; rx++) {
        const xCenter = Math.min(W-1, Math.floor(rx*step + step/2));

        // Find nearest site under chosen metric
        let best = Infinity, bestIdx = -1;
        const sx = xCenter, sy = yCenter;
        for (let i=0; i<sitesXY.length; i++) {
          const s = sitesXY[i];
          const d = (metric==="l1") ? manhattan(sx,sy,s[0],s[1]) : euclid2(sx,sy,s[0],s[1]);
          if (d < best) { best = d; bestIdx = i; }
        }
        const [r,g,b] = d3.color(palette[bestIdx % palette.length]).rgb().array();

        // Paint the tile (rx,ry)
        const x0 = rx*step|0, y0 = ry*step|0;
        const w  = Math.min(step, W - x0)|0;
        const h  = Math.min(step, H - y0)|0;

        for (let ty=0; ty<h; ty++) {
          let idx = ((y0 + ty)*W + x0) * 4;
          for (let tx=0; tx<w; tx++) {
            data[idx++] = r; data[idx++] = g; data[idx++] = b; data[idx++] = 255;
          }
        }
      }
    }
    ctx.putImageData(img, 0, 0);

    r0 = r1;
    if (r0 < rows) {
      requestAnimationFrame(processChunk);
    } else {
      // draw site marks on top
      ctx.restore(); // remove clip to draw dots intact
      ctx.save();
      ctx.fillStyle = "#111";
      for (const s of sitesXY) {
        ctx.beginPath();
        ctx.arc(s[0], s[1], 1.8, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
      console.log("finished");
    }
  }
  processChunk();
}

/** main */
(async function main() {
  const { boundary, sites } = await loadData();

  const { projection } = fitProjection(boundary);
  const clipPath = boundaryPath2D(boundary, projection);

  // Project sites to screen coords
  const sitesXY = sites.map(({lon,lat}) => projection([lon,lat])).filter(Boolean);

  function run() {
    const metric = metricSel.value; // l1 or l2
    const slider = +resInput.value; // 2..12
    // map slider to pixel step: bigger slider → bigger step → faster
    const step = Math.round(d3.scaleLinear().domain([2,12]).range([3,20])(slider));
    resLabel.textContent = slider + " (tile " + step + "px)";
    renderVoronoi({ sitesXY, metric, step, clipPath });
  }

  renderBtn.addEventListener("click", run);
  resInput.addEventListener("input", () => { resLabel.textContent = resInput.value; });
  run();
})();
</script>
</body>
</html>
